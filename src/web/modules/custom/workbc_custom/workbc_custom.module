<?php

use Drupal\Core\Access\AccessResult;
use Drupal\node\NodeInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Config\Entity\ConfigEntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Url;
use Drupal\Core\Routing\TrustedRedirectResponse;
use Drupal\redirect\Entity\Redirect;
use Symfony\Component\HttpFoundation\Request;

/**
 * Implements hook_theme().
 */

 function workbc_custom_theme($existing, $type, $theme, $path) {
   return [
     'related_topics_block' => [
       'variables' => [
           'related_topics' => array(
               'image' => NULL,
               'top_level_parent' => NULL,
               'title' => NULL,
               'body' => NULL,
               'action' => NULL,
           ),
       ],
     ],
     'explore_careers_block' => [
       'variables' => [
           'explore_careers' => array(
               'title' => NULL,
               'body' => NULL,
               'title_1' => NULL,
               'body_1' => NULL,
               'action_1' => NULL,
               'tooltip_1' => NULL,
               'title_2' => NULL,
               'body_2' => NULL,
               'action_2' => NULL,
           ),
       ],
     ],
     'career_events_block' => [
       'variables' => [
           'career_events' => array(
             'list' => NULL,
             'calendar' => NULL,
           ),
       ],
     ],
   ];
 }


 /**
  * Implements hook_views_data_alter().
  */
 function workbc_custom_views_data_alter(array &$data) {

   $data['node_field_data']['workbc_nodes_granular_dates'] = [
     'title' => t('WorkBC node granular date filter'),
     'filter' => [
       'title' => t('WorkBC node granular date filter'),
       'help' => t('WorkBC node granular date filter.'),
       'field' => 'title',
       'id' => 'workbc_node_granular_date_filter',
     ],
   ];

 }

/**
 * Implements hook_form_alter().
 */
function workbc_custom_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {

  // hide password and disable editing of username and email
  // maintenance of this info is handled by keycloak
  if ($form_id == "user_form") {
    $form['account']['mail']['#disabled'] = true;
    $form['account']['name']['#disabled'] = true;
    $form['account']['pass']['#access'] = false;
    $form['account']['mail']['#description'] = "";

    $user = \Drupal::currentUser();
    if (!$user->hasPermission("bypass content groups")) {
      $form['field_content_group']['#disabled'] = true;
    }
    // allow edit if super user
    if ($user->id() == 1) {
      $form['account']['name']['#disabled'] = false;
      $form['account']['mail']['#disabled'] = false;
    }
  }


  if($form_id == "hoo_options"){
    $form['#attached']['library'][] =  'workbc_custom/custom-script';
  }

}


/**
 * Implements hook_node_access().
 *
 */
function workbc_custom_node_access(NodeInterface $node, $op, AccountInterface $account) {

  // we only allow update/delete of node if user is a member of the same content group
  // as the node or the user has "bypass content groups" permission.
  if ($op == "update" || $op == "delete") {
    if (!$account->hasPermission("bypass content groups")) {
      $user = \Drupal\user\Entity\User::load($account->id());
      if (!isset($user->field_content_group->target_id) ||
          !isset($node->field_content_group->target_id) ||
          $user->field_content_group->target_id <> $node->field_content_group->target_id) {
        return  AccessResult::forbidden();
      }
    }
  }
  return AccessResult::neutral();
}


/**
 * Implements hook_node_presave().
 */
function workbc_custom_node_presave(NodeInterface $entity) {

  // if this is a new node and user doesn't have bypass content groups hasPermission
  // we set the content group for the node to the same group as the user.
  if ($entity->isNew()) {
    if (!\Drupal::currentUser()->hasPermission('bypass content groups')) {
      $user = \Drupal\user\Entity\User::load(\Drupal::currentUser()->id());
      if (isset($user->field_content_group->target_id)) {
        $entity->get('field_content_group')->setValue($user->field_content_group->target_id);
      }
    }
  }
}

/**
 * Implements hook_user_access().
 */
function workbc_custom_user_access(EntityInterface $entity, $operation, AccountInterface $account) {

  // users without "bypass content groups" permission can only update/delete
  // user accounts if they are members of the same content group
  if ($operation == "update" || $operation == "delete") {
    if (!\Drupal::currentUser()->hasPermission('bypass content groups')) {
      $admin = \Drupal\user\Entity\User::load(\Drupal::currentUser()->id());
      if (!isset($admin->field_content_group->target_id) ||
          is_null($admin->field_content_group) ||
          !isset($entity->field_content_group->target_id) ||
          is_null($entity->field_content_group) ||
          $admin->field_content_group->target_id <> $entity->field_content_group->target_id) {
        return  AccessResult::forbidden();
      }
    }
  }
  // No opinion.
  return AccessResult::neutral();
}

/**
 * Implements hook_entity_operation_alter().
 */
function workbc_custom_entity_operation_alter(array &$operations, EntityInterface $entity) {

  // remove role operation, roles can be changed via edit tab.
  // this operation is unnecessary and gives certain users access when they shouldn't
  if ($entity->getEntityTypeId() == "user") {
    if (isset($operations['role_delegation'])) {
      unset($operations['role_delegation']);
    }
  }
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function workbc_custom_menu_local_tasks_alter(&$data, $route_name) {

  // remove role tab, roles can be changed via edit tab.
  // this operation is unnecessary and gives certain users access when they shouldn't
  if (isset($data['tabs'][0]['role_delegation.edit_form'])) {
    unset($data['tabs'][0]['role_delegation.edit_form']);
  }
}

/**
 * Implements hook_webform_element_alter().
 */
function workbc_custom_webform_element_alter(array &$element, FormStateInterface $form_state, array $context) {
  if (isset($element['#webform_id']) && $element['#webform_id'] === 'contact--name') {
    $element['#element_validate'][] = 'workbc_custom_webform_contact_name_validate';
  }
}

function workbc_custom_webform_contact_name_validate(array &$element, FormStateInterface $form_state, array &$form) {
  $form_state->setValue('name', urlencode($form_state->getValue('name')));
}

/**
 * Implements hook_form_FORM_ID_alter() for config_admin_import_form.
 *
 * Show export link for each modified config item.
 */
function workbc_custom_form_config_admin_import_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $configs = [];
  foreach (\Drupal::service('entity_type.manager')->getDefinitions() as $entity_type => $definition) {
    if ($definition->entityClassImplements(ConfigEntityInterface::class)) {
      $entity_storage = \Drupal::service('entity_type.manager')->getStorage($entity_type);
      foreach ($entity_storage->loadMultiple() as $entity) {
        $configs[$definition->getConfigPrefix() . '.' . $entity->id()] = [
          'config_type' => $entity_type,
          'config_name' => $entity->id(),
        ];
      }
    }
  }

  $collection = '';
  $config_change_type = 'update';
  if (!empty($form[$collection][$config_change_type]['list']['#rows'])) foreach ($form[$collection][$config_change_type]['list']['#rows'] as &$config_change) {
    $config_item = $config_change['name'];

    if (array_key_exists($config_item, $configs)) {
      $config_type = $configs[$config_item]['config_type'];
      $config_name = $configs[$config_item]['config_name'];
    }
    else {
      $config_type = 'system.simple';
      $config_name = $config_item;
    }

    $config_change['operations']['data']['#links']['export'] = [
      'title' => t('Export config'),
      'url' => Url::fromRoute('config.export_single', [
        'config_type' => $config_type,
        'config_name' => $config_name,
      ]),
    ];
  }
}

/**
 * Implements hook_redirect_response_alter().
 *
 * Capture a Find Jobs redirect and add the noc argument if searchNOC is present.
 */
function workbc_custom_redirect_response_alter(TrustedRedirectResponse $response, Redirect $redirect, Request $request) {
  if (!empty($request->query) && $request->query->has('searchNOC')) {
    $noc = $request->query->get('searchNOC');
    $response->setTargetUrl($response->getTargetUrl() . "#/job-search;noc=$noc;");
  }
}

/**
 * Get SSOT data for the High Opportunity block.
 */
function ssotHighOpportunityOptions($parameters = null){
  $data = array();
  $data['data'] = querySSoT('high_opportunity_occupations?' . $parameters);

  //options
  $data['options'] = querySSoT('high_opportunity_occupations?select=typical_education_background,region');

  //schema
  $data['schema'] = ssotSchema();

  return $data;
}

/**
 * Function to get the region mappings.
 */
function getRegionMappings() {
  $region_map = [
    'all' => 'All regions',
    'british_columbia' => 'British Columbia',
    'vancouver_island_coast' =>'Vancouver Island/Coast',
    'mainland_southwest'  => 'Mainland/Southwest',
    'thompson_okanagan' => 'Thompson-Okanagan',
    'kootenay' => 'Kootenay',
    'cariboo' => 'Cariboo',
    'north_coast_nechako' => 'North Coast and Nechako',
    'northeast' => 'Northeast'
  ];
  return $region_map;
}

/**
 * Function to identify rich text content fields that contain unmanaged files.
 *
 * We iterate on all text fields for nodes/paragraphs whose format is full_html,
 * Identify the field's data table,
 * Query all its rows,
 * Match each value column with:
 * - a file entity type signature (data-entity-type="file")
 * - a straight file reference (src="/sites/default/files/XXX")
 * For each match, we attempt to identify an existing media record,
 *   by querying the file_managed x file_usage tables to match the file uuid or path, respectively.
 */
function getUnmanagedFiles() {
  $fields = [];
  foreach (['node', 'paragraph'] as $entity) {
    foreach (\Drupal::service('entity_type.bundle.info')->getBundleInfo($entity) as $bundle => $bundle_info) {
      foreach (\Drupal::service('entity_field.manager')->getFieldDefinitions($entity, $bundle) as $field => $field_info) {
        if (str_contains($field_info->getType(), 'text')) {
          $fields[$field] = $field_info;
        }
      }
    }
  }

  $results = [];
  $connection = \Drupal::database();
  foreach ($fields as $field => $field_info) {
    $entity = $field_info->getTargetEntityTypeId();
    $entity_storage = \Drupal::entityTypeManager()->getStorage($entity);
    $table_mapping = $entity_storage->getTableMapping();
    $field_storage_definition = $field_info->getFieldStorageDefinition();
    $table = $table_mapping->getDedicatedDataTableName($field_storage_definition);
    $query = $connection->select($table);
    $query->addField($table, "{$field}_value");
    $query->addField($table, "{$field}_format");
    $query->addField($table, "entity_id");
    $rows = $query->execute()->fetchAll();
    foreach ($rows as $row) {
      if ($row->{"{$field}_format"} === 'full_html') {
        $row_matches = [];
        if (preg_match_all('/data-entity-type="file" data-entity-uuid="([a-z0-9-]+)" src="(\/sites\/default\/files\/[^"]+)"/', $row->{"{$field}_value"}, $matches, PREG_SET_ORDER) > 0) {
          foreach ($matches as $match) {
            $row_matches[] = [
              'match' => $match[0],
              'file_uuid' => $match[1],
              'file_path' => $match[2],
              'media_id' => $connection->query("
                select distinct fu.id
                from file_managed fm inner join file_usage fu on fu.fid = fm.fid
                where fu.type = 'media' and
                fm.uuid = :uuid
              ", [':uuid' => $match[1]])?->fetchField()
            ];
          }
        }
        if (preg_match_all('/src="(\/sites\/default\/files\/[^"]+)"/', $row->{"{$field}_value"}, $matches, PREG_SET_ORDER) > 0) {
          foreach ($matches as $match) {
            // Eliminate matches from above.
            foreach ($row_matches as $row_match) {
              if ($row_match['file_path'] === $match[1]) continue 2;
            }
            $row_matches[] = [
              'match' => $match[0],
              'file_uuid' => null,
              'file_path' => $match[1],
              'media_id' => $connection->query("
                select distinct fu.id
                from file_managed fm inner join file_usage fu on fu.fid = fm.fid
                where fu.type = 'media' and
                fm.uri = :uri
              ", [':uri' => str_replace('/sites/default/files/', 'public://', urldecode($match[1]))])?->fetchField()
            ];
          }
        }
        if (!empty($row_matches)) {
          $options = [
            'absolute' => false,
            'attributes' => [
              'target' => '_blank',
            ]
          ];
          if ($entity === 'node') {
            $node = \Drupal::entityTypeManager()->getStorage('node')->load($row->entity_id);
            $url = Url::fromRoute('entity.node.edit_form', [
              'node' => $row->entity_id
            ], $options);
          }
          else if ($entity === 'paragraph') {
            $paragraph = \Drupal::entityTypeManager()->getStorage('paragraph')->load($row->entity_id);
            $node = \Drupal::entityTypeManager()->getStorage('node')->load($paragraph->get('parent_id')->value);
            $url = Url::fromRoute('paragraphs_edit.edit_form', [
              'root_parent' => $paragraph->get('parent_id')->value,
              'root_parent_type' => $paragraph->get('parent_type')->value,
              'paragraph' => $row->entity_id
            ], $options);
          }
          $results[] = [
            'title' => $node->get('title')->value,
            'entity' => $entity,
            'bundle' => $field_info->getTargetBundle(),
            'field' => $field,
            'label' => $field_info->getLabel(),
            'edit_url' => $url,
            'matches' => $row_matches,
          ];
        }
      }
    }
  }
  return $results;
}
