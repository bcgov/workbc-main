<?php

use Drupal\Core\Access\AccessResult;
use Drupal\node\NodeInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Config\Entity\ConfigEntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Url;
use Drupal\Core\Routing\TrustedRedirectResponse;
use Drupal\redirect\Entity\Redirect;
use Symfony\Component\HttpFoundation\Request;

/**
 * Implements hook_theme().
 */

 function workbc_custom_theme($existing, $type, $theme, $path) {
   return [
     'related_topics_block' => [
       'variables' => [
           'related_topics' => array(
               'image' => NULL,
               'top_level_parent' => NULL,
               'title' => NULL,
               'body' => NULL,
               'action' => NULL,
           ),
       ],
     ],
     'explore_careers_block' => [
       'variables' => [
           'explore_careers' => array(
               'title' => NULL,
               'body' => NULL,
               'title_1' => NULL,
               'body_1' => NULL,
               'action_1' => NULL,
               'tooltip_1' => NULL,
               'title_2' => NULL,
               'body_2' => NULL,
               'action_2' => NULL,
           ),
       ],
     ],
     'career_events_block' => [
       'variables' => [
           'career_events' => array(
             'list' => NULL,
             'calendar' => NULL,
           ),
       ],
     ],
   ];
 }


 /**
  * Implements hook_views_data_alter().
  */
 function workbc_custom_views_data_alter(array &$data) {

   $data['node_field_data']['workbc_nodes_granular_dates'] = [
     'title' => t('WorkBC node granular date filter'),
     'filter' => [
       'title' => t('WorkBC node granular date filter'),
       'help' => t('WorkBC node granular date filter.'),
       'field' => 'title',
       'id' => 'workbc_node_granular_date_filter',
     ],
   ];

 }

/**
 * Implements hook_form_alter().
 */
function workbc_custom_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {

  // hide password and disable editing of username and email
  // maintenance of this info is handled by keycloak
  if ($form_id === 'user_form') {
    $form['account']['mail']['#disabled'] = true;
    $form['account']['name']['#disabled'] = true;
    $form['account']['pass']['#access'] = false;
    $form['account']['mail']['#description'] = "";

    $user = \Drupal::currentUser();
    if (!$user->hasPermission('bypass content groups')) {
      $form['field_content_group']['#disabled'] = true;
    }
    // allow edit if super user
    if ($user->id() == 1) {
      $form['account']['name']['#disabled'] = false;
      $form['account']['mail']['#disabled'] = false;
    }
  }

  if ($form_id === 'hoo_options'){
    $form['#attached']['library'][] =  'workbc_custom/custom-script';
  }

}

/**
 * Implements hook_entity_form_mode_alter().
 */
function workbc_custom_entity_form_mode_alter(&$form_mode, Drupal\Core\Entity\EntityInterface $entity) {
  if ($entity->getEntityTypeId() === 'media' && \Drupal::request()->query->get('form_mode')) {
    $form_mode = \Drupal::request()->query->get('form_mode');
  }
}

/**
 * Implements hook_node_access().
 *
 */
function workbc_custom_node_access(NodeInterface $node, $op, AccountInterface $account) {

  // we only allow update/delete of node if user is a member of the same content group
  // as the node or the user has "bypass content groups" permission.
  if ($op == "update" || $op == "delete") {
    if (!$account->hasPermission("bypass content groups")) {
      $user = \Drupal\user\Entity\User::load($account->id());
      if (!isset($user->field_content_group->target_id) ||
          !isset($node->field_content_group->target_id) ||
          $user->field_content_group->target_id <> $node->field_content_group->target_id) {
        return  AccessResult::forbidden();
      }
    }
  }
  return AccessResult::neutral();
}


/**
 * Implements hook_node_presave().
 */
function workbc_custom_node_presave(NodeInterface $entity) {

  // if this is a new node and user doesn't have bypass content groups hasPermission
  // we set the content group for the node to the same group as the user.
  if ($entity->isNew()) {
    if (!\Drupal::currentUser()->hasPermission('bypass content groups')) {
      $user = \Drupal\user\Entity\User::load(\Drupal::currentUser()->id());
      if (isset($user->field_content_group->target_id)) {
        $entity->get('field_content_group')->setValue($user->field_content_group->target_id);
      }
    }
  }
}

/**
 * Implements hook_user_access().
 */
function workbc_custom_user_access(EntityInterface $entity, $operation, AccountInterface $account) {

  // users without "bypass content groups" permission can only update/delete
  // user accounts if they are members of the same content group
  if ($operation == "update" || $operation == "delete") {
    if (!\Drupal::currentUser()->hasPermission('bypass content groups')) {
      $admin = \Drupal\user\Entity\User::load(\Drupal::currentUser()->id());
      if (!isset($admin->field_content_group->target_id) ||
          is_null($admin->field_content_group) ||
          !isset($entity->field_content_group->target_id) ||
          is_null($entity->field_content_group) ||
          $admin->field_content_group->target_id <> $entity->field_content_group->target_id) {
        return  AccessResult::forbidden();
      }
    }
  }
  // No opinion.
  return AccessResult::neutral();
}

/**
 * Implements hook_entity_operation_alter().
 */
function workbc_custom_entity_operation_alter(array &$operations, EntityInterface $entity) {

  // remove role operation, roles can be changed via edit tab.
  // this operation is unnecessary and gives certain users access when they shouldn't
  if ($entity->getEntityTypeId() == "user") {
    if (isset($operations['role_delegation'])) {
      unset($operations['role_delegation']);
    }
  }
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function workbc_custom_menu_local_tasks_alter(&$data, $route_name) {

  // remove role tab, roles can be changed via edit tab.
  // this operation is unnecessary and gives certain users access when they shouldn't
  if (isset($data['tabs'][0]['role_delegation.edit_form'])) {
    unset($data['tabs'][0]['role_delegation.edit_form']);
  }
}

/**
 * Implements hook_webform_element_alter().
 */
function workbc_custom_webform_element_alter(array &$element, FormStateInterface $form_state, array $context) {
  if (isset($element['#webform_id']) && $element['#webform_id'] === 'contact--name') {
    $element['#element_validate'][] = 'workbc_custom_webform_contact_name_validate';
  }
}

function workbc_custom_webform_contact_name_validate(array &$element, FormStateInterface $form_state, array &$form) {
  $form_state->setValue('name', urlencode($form_state->getValue('name')));
}

/**
 * Implements hook_form_FORM_ID_alter() for config_admin_import_form.
 *
 * Show export link for each modified config item.
 */
function workbc_custom_form_config_admin_import_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $configs = [];
  foreach (\Drupal::service('entity_type.manager')->getDefinitions() as $entity_type => $definition) {
    if ($definition->entityClassImplements(ConfigEntityInterface::class)) {
      $entity_storage = \Drupal::service('entity_type.manager')->getStorage($entity_type);
      foreach ($entity_storage->loadMultiple() as $entity) {
        $configs[$definition->getConfigPrefix() . '.' . $entity->id()] = [
          'config_type' => $entity_type,
          'config_name' => $entity->id(),
        ];
      }
    }
  }

  $collection = '';
  $config_change_type = 'update';
  if (!empty($form[$collection][$config_change_type]['list']['#rows'])) foreach ($form[$collection][$config_change_type]['list']['#rows'] as &$config_change) {
    $config_item = $config_change['name'];

    if (array_key_exists($config_item, $configs)) {
      $config_type = $configs[$config_item]['config_type'];
      $config_name = $configs[$config_item]['config_name'];
    }
    else {
      $config_type = 'system.simple';
      $config_name = $config_item;
    }

    $config_change['operations']['data']['#links']['export'] = [
      'title' => t('Export config'),
      'url' => Url::fromRoute('config.export_single', [
        'config_type' => $config_type,
        'config_name' => $config_name,
      ]),
    ];
  }
}

/**
 * Implements hook_redirect_response_alter().
 *
 * Capture a Find Jobs redirect and add the noc argument if searchNOC is present.
 */
function workbc_custom_redirect_response_alter(TrustedRedirectResponse $response, Redirect $redirect, Request $request) {
  if (!empty($request->query) && $request->query->has('searchNOC')) {
    $noc = $request->query->get('searchNOC');
    $response->setTargetUrl($response->getTargetUrl() . "#/job-search;noc=$noc;");
  }
}

/**
 * Get SSOT data for the High Opportunity block.
 */
function ssotHighOpportunityOptions($parameters = null){
  $data = array();
  $data['data'] = querySSoT('high_opportunity_occupations?' . $parameters);

  //options
  $data['options'] = querySSoT('high_opportunity_occupations?select=typical_education_background,region');

  //schema
  $data['schema'] = ssotSchema();

  return $data;
}

/**
 * Function to get the region mappings.
 */
function getRegionMappings() {
  $region_map = [
    'all' => 'All regions',
    'british_columbia' => 'British Columbia',
    'vancouver_island_coast' =>'Vancouver Island/Coast',
    'mainland_southwest'  => 'Mainland/Southwest',
    'thompson_okanagan' => 'Thompson-Okanagan',
    'kootenay' => 'Kootenay',
    'cariboo' => 'Cariboo',
    'north_coast_nechako' => 'North Coast and Nechako',
    'northeast' => 'Northeast'
  ];
  return $region_map;
}

function getRichTextFields($entities = ['node', 'paragraph']) {
  $fields = [];
  foreach ($entities as $entity) {
    foreach (\Drupal::service('entity_type.bundle.info')->getBundleInfo($entity) as $bundle => $bundle_info) {
      foreach (\Drupal::service('entity_field.manager')->getFieldDefinitions($entity, $bundle) as $field => $field_info) {
        if (str_contains($field_info->getType(), 'text')) {
          $entity_type = $field_info->getTargetEntityTypeId();
          $entity_storage = \Drupal::entityTypeManager()->getStorage($entity_type);
          $table_mapping = $entity_storage->getTableMapping();
          $field_storage_definition = $field_info->getFieldStorageDefinition();
          $table = $table_mapping->getDedicatedDataTableName($field_storage_definition);
          $fields[$field] = [
            'field_info' => $field_info,
            'entity' => $entity_type,
            'table' => $table,
          ];
        }
      }
    }
  }
  return $fields;
}

/**
 * Function to identify rich text content fields that contain unmanaged files.
 *
 * We iterate on all text fields for nodes/paragraphs whose format is full_html,
 * Identify the field's data table,
 * Query all its rows,
 * Match each value column with:
 * - a file entity type signature (data-entity-type="file")
 * - a straight file reference (src="/sites/default/files/XXX")
 * For each match, we attempt to identify an existing media record,
 *   by querying the file_managed x file_usage tables to match the file uuid or path, respectively.
 */
function getUnmanagedFiles() {
  $rich_text_fields = getRichTextFields();
  $results = [];
  $connection = \Drupal::database();
  foreach ($rich_text_fields as $field => $info) {
    $field_info = $info['field_info'];
    $entity = $info['entity'];
    $table = $info['table'];
    $query = $connection->select($table);
    $query->addField($table, "{$field}_value");
    $query->addField($table, 'entity_id');
    $rows = $query->execute()->fetchAll();
    foreach ($rows as $row) {
      $row_matches = [];
      if (preg_match_all('/<img\s[^>]*data-entity-type="file" data-entity-uuid="([a-z0-9-]+)"\s[^>]*src="(\/sites\/default\/files\/[^"]+)"[^>]*\/>/', $row->{"{$field}_value"}, $matches, PREG_SET_ORDER) > 0) {
        foreach ($matches as $match) {
          $file = $connection->query("
            select fm.fid, fu.id
            from file_managed fm left join file_usage fu on fu.fid = fm.fid and fu.type = 'media'
            where fm.uuid = :uuid
          ", [':uuid' => $match[1]])->fetchObject();
          $row_matches[] = [
            'type' => 'img',
            'match' => $match[0],
            'file_uuid' => $match[1],
            'file_path' => $match[2],
            'media_id' => $file->id,
            'file_id' => $file->fid,
          ];
        }
      }
      if (preg_match_all('/href="(\/sites\/default\/files\/[^"]+)"/', $row->{"{$field}_value"}, $matches, PREG_SET_ORDER) > 0) {
        foreach ($matches as $match) {
          $path = explode('#', urldecode($match[1]))[0];
          $file = $connection->query("
            select fm.fid, fu.id
            from file_managed fm left join file_usage fu on fu.fid = fm.fid and fu.type = 'media'
            where fm.uri ilike :uri
          ", [':uri' => str_replace('/sites/default/files/', 'public://', $path)])->fetchObject();
          $row_matches[] = [
            'type' => 'href',
            'match' => $match[0],
            'file_uuid' => null,
            'file_path' => $match[1],
            'media_id' => $file->id,
            'file_id' => $file->fid,
          ];
        }
      }
      if (preg_match_all('/src="(https:\/\/[^\.]+\.gathercontent\.com\/[^"]+)"/', $row->{"{$field}_value"}, $matches, PREG_SET_ORDER) > 0) {
        foreach ($matches as $match) {
          $row_matches[] = [
            'type' => 'gathercontent',
            'match' => $match[0],
            'file_uuid' => null,
            'file_path' => $match[1],
            'media_id' => null,
            'file_id' => null,
          ];
        }
      }
      if (!empty($row_matches)) {
        if ($entity === 'node') {
          $node_id = $row->entity_id;
        }
        else if ($entity === 'paragraph') {
          $paragraph = \Drupal::entityTypeManager()->getStorage('paragraph')->load($row->entity_id);
          while ($paragraph->get('parent_type')->value === 'paragraph') {
            $paragraph = \Drupal::entityTypeManager()->getStorage('paragraph')->load($paragraph->get('parent_id')->value);
          }
          $node_id = $paragraph->get('parent_id')->value;
        }
        $results[] = [
          'node_id' => $node_id,
          'entity' => $entity,
          'entity_id' => $row->entity_id,
          'bundle' => $field_info->getTargetBundle(),
          'field' => $field,
          'label' => $field_info->getLabel(),
          'matches' => $row_matches,
        ];
      }
    }
  }
  return $results;
}

/**
 * Function to find duplicate files in the Drupal public file directory.
 */
function getDuplicateFiles() {
  $connection = \Drupal::database();
  $files = $connection->query("
    select fm.fid, fm.sha1, fm.uri, fu.id as media_id
    from {file_managed} fm left join {file_usage} fu on fu.fid = fm.fid and fu.type = 'media'
    where sha1 is not null
  ");
  $duplicates = [];
  foreach ($files as $file) {
    // Discard some results.
    $file_path = str_replace('public://', './sites/default/files/', $file->uri);
    foreach (['media-icons/', 'oembed_thumbnails/'] as $discard) {
      if (str_contains($file->uri, $discard)) continue 2;
    }
    $duplicates[$file->sha1][$file->media_id ?? null] = [
      'file_id' => $file->fid,
      'media_id' => $file->media_id,
      'file_path' => $file_path,
      'usages' => []
    ];
  }
  $duplicates = array_filter($duplicates, function ($candidates) { return count($candidates) > 1; });

  // Identify content usage for each identified media.
  $rich_text_fields = getRichTextFields();
  foreach ($duplicates as &$candidates) {
    foreach ($candidates as &$d) {
      if (empty($d['media_id'])) continue;

      $media_id = $d['media_id'];
      $media = \Drupal::entityTypeManager()
      ->getStorage('media')
      ->load($media_id);

      // Flag deleted media - it's a bug.
      if (empty($media)) {
        $d['usages'][] = [
          'type' => 'deleted'
        ];
      }

      // Identify the duplicate media in the reference fields.
      foreach ([
        ['node', 'field_hero_image_media'],
        ['node', 'field_image_media'],
        ['node', 'field_publication_media'],
        ['paragraph', 'field_image_media'],
        ['paragraph', 'field_icon'],
      ] as $entity_field) {
        $table = $entity_field[0] . '__' . $entity_field[1];
        $query = $connection->select($table);
        $query->addField($table, 'entity_id');
        $query->condition($entity_field[1] . '_target_id', $media_id);
        foreach ($query->execute() as $row) {
          $d['usages'][] = [
            'entity' => $entity_field[0],
            'entity_id' => $row->entity_id,
            'field' => $entity_field[1],
            'type' => 'reference'
          ];
        }
      }

      // Identify the duplicate media in the link fields.
      foreach ([
        ['paragraph', 'field_link'],
      ] as $entity_field) {
        $table = $entity_field[0] . '__' . $entity_field[1];
        $query = $connection->select($table);
        $query->addField($table, 'entity_id');
        $query->condition($entity_field[1] . '_uri', 'internal:/media/' . $media_id . '/download%', 'LIKE');
        foreach ($query->execute() as $row) {
          $d['usages'][] = [
            'entity' => $entity_field[0],
            'entity_id' => $row->entity_id,
            'field' => $entity_field[1],
            'type' => 'link'
          ];
        }
      }

      // Identify the duplicate media in the rich content fields.
      foreach ($rich_text_fields as $field => $info) {
        $table = $info['table'];
        $query = $connection->select($table);
        $query->addField($table, 'entity_id');
        $query->condition(
          $query->orConditionGroup()
          ->condition("{$field}_value", '%' . ($media?->uuid() ?? '00000000-0000-0000-0000-000000000000') . '%', 'LIKE')
          ->condition("{$field}_value", '%/media/' . $media_id . '/download%', 'LIKE')
        );
        foreach ($query->execute() as $row) {
          $d['usages'][] = [
            'entity' => $info['entity'],
            'entity_id' => $row->entity_id,
            'field' => $field,
            'type' => 'text'
          ];
        }
      }
    }
  }

  return $duplicates;
}
