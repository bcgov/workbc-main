<?php

use Drupal\Core\StreamWrapper\StreamWrapperManager;
use GuzzleHttp\Client;
use GuzzleHttp\Exception\RequestException;
use Psr\Http\Message\ResponseInterface;

const SSOT_ROUTES = [
  'workbc_ssot.lmmu',
  'view.ssot_log.page_1'
];

const SSOT_DATASETS = [
  'wages' => [
    'noc_key' => 'noc',
    'fields' => 'noc,calculated_median_annual_salary',
  ],
  'career_provincial' => [
    'noc_key' => 'noc',
    'fields' => 'noc,expected_job_openings_10y',
  ],
  'career_regional' => [
    'noc_key' => 'noc',
    'fields' => 'noc,cariboo_expected_number_of_job_openings_10y,kootenay_expected_number_of_job_openings_10y,mainland_southwest_expected_number_of_job_openings_10y,north_coast_nechako_expected_number_of_job_openings_10y,northeast_expected_number_of_job_openings_10y,thompson_okanagan_expected_number_of_job_openings_10y,vancouver_island_coast_expected_number_of_job_openings_10y',
  ],
  'census' => [],
  'education' => [
    'noc_key' => 'noc',
    'fields' => 'noc,teer'
  ],
  'fyp_categories_interests' => [
    'noc_key' => 'noc_2021',
    'fields' => 'noc_2021,category,interest',
    'endpoint' => 'fyp_categories_interests_nocs'
  ],
  'high_opportunity_occupations' => [],
  'industries' => [],
  'industry_outlook' => [],
  'labour_force_survey_industry' => [],
  'labour_force_survey_regional_employment' => [],
  'labour_force_survey_regional_industry_province' => [],
  'labour_force_survey_regional_industry_region' => [],
  'monthly_labour_market_updates' => [],
  'occupational_interests' => [],
  'openings_careers' => [],
  'openings_industry' => [],
  'regional_labour_market_outlook' => [],
  'regional_top_occupations' => [],
  'skills' => [],
  'titles' => [
    'noc_key' => 'noc',
    'fields' => 'noc,commonjobtitle'
  ],
  'lmo_report_2024_job_openings_10y' => [],
  'lmo_report_2024_job_openings_annual' => [],
  'lmo_report_2024_job_openings_teers' => [],
  'lmo_report_2024_job_openings_industries' => [],
  'lmo_report_2024_job_openings_broad_categories' => [],
  'lmo_report_2024_job_openings_regions' => [],
  'lmo_report_2024_job_openings_vancouver_island_coast' => [],
  'lmo_report_2024_job_openings_mainland_southwest' => [],
  'lmo_report_2024_job_openings_thompson_okanagan' =>[],
  'lmo_report_2024_job_openings_kootenay' => [],
  'lmo_report_2024_job_openings_cariboo' => [],
  'lmo_report_2024_job_openings_north_coast_nechako' => [],
  'lmo_report_2024_job_openings_northeast' => [],
];

/**
 * Implements hook_cron.
 *
 * Get the latest datasets from SSOT.
 */
function workbc_ssot_cron() {
  // Retrieve the local state, making sure we set any modified datasets to null.
  $local_dates = array_merge(array_combine(
    array_keys(SSOT_DATASETS),
    array_fill(0, count(SSOT_DATASETS), null)
  ), \Drupal::state()->get('workbc.ssot_dates', []));

  // Get the latest update dates from SSOT.
  $result = ssot(
    'sources?' . http_build_query([
      'select' => 'endpoint,date',
      'endpoint' => 'in.("' . join('","', array_keys(SSOT_DATASETS)) . '")',
      'order' => 'date.desc'
    ])
  );
  if (!$result) return;
  $ssot_dates = json_decode($result->getBody());

  // Compare each local date with remote date, scheduling a download job if needed.
  $datasets = [];
  foreach ($ssot_dates as $ssot_date) {
    if (empty($ssot_date->date)) continue;
    $date1 = DateTimeImmutable::createFromFormat(DateTimeInterface::ATOM, $ssot_date->date);
    if (!$date1) {
      \Drupal::logger('workbc')->error('Error parsing date @date for SSOT dataset @dataset: @errors', [
        '@date' => $ssot_date->date,
        '@dataset' => $ssot_date->endpoint,
        '@errors' => print_r(DateTimeImmutable::getLastErrors()),
      ]);
      continue;
    }
    $date2 = empty($local_dates[$ssot_date->endpoint]) ? false : DateTimeImmutable::createFromFormat(DateTimeInterface::ATOM, $local_dates[$ssot_date->endpoint]);
    if (empty($date2) || $date2 < $date1) {
      // Some datasets have multiple entries. Pick the latest date and ignore the rest.
      if (array_key_exists($ssot_date->endpoint, $datasets) && $date1 <= DateTimeImmutable::createFromFormat(DateTimeInterface::ATOM, $datasets[$ssot_date->endpoint]->date)) continue;

      \Drupal::logger('workbc')->notice('Found an update for SSOT dataset @dataset.', [
        '@dataset' => $ssot_date->endpoint
      ]);
      $datasets[$ssot_date->endpoint] = $ssot_date;
    }
    else {
      \Drupal::logger('workbc')->notice('No update for SSOT dataset @dataset.', [
        '@dataset' => $ssot_date->endpoint
      ]);
    }
  }

  if (!empty($datasets)) {
    // Clear the rendered cache to force pages to refresh their virtual fields with updated data points.
    \Drupal\Core\Cache\Cache::invalidateTags(['rendered']);

    $datasets_enqueued = [];
    foreach ($datasets as $dataset) {
      // Enqueue a job to update the career profiles with each qualifying updated dataset.
      if (array_key_exists('noc_key', SSOT_DATASETS[$dataset->endpoint])) {
        $datasets_enqueued[] = $dataset;
      }
      // Otherwise, just update the local date to reflect the latest date.
      else {
        $local_dates[$dataset->endpoint] = $dataset->date;
      }
    }

    // Invoke the background job to download datasets.
    if (!empty($datasets_enqueued)) {
      Drupal::queue('ssot_downloader')->createItem([
        'datasets' => $datasets_enqueued,
      ]);
    }

    // Reset the SSOT local update dates.
    \Drupal::state()->set('workbc.ssot_dates', $local_dates);
  }
}

/**
 * Implements hook_file_download().
 */
function workbc_ssot_file_download($uri) {
  $scheme = StreamWrapperManager::getScheme($uri);
  $target = StreamWrapperManager::getTarget($uri);
  if ($scheme === 'private' && str_starts_with($target, 'ssot/')) {
    $filename = basename($target);
    return [
      'Content-disposition' => "attachment; filename=\"$filename\"",
    ];
  }
}

/**
 * Implements hook_element_info_alter().
 */
function workbc_ssot_element_info_alter(array &$types) {
  $types['datetime']['#process'][] = 'workbc_ssot_process_element';
}

/**
 * Element process callback for datetime fields.
 */
function workbc_ssot_process_element($element) {
  $element['time']['#attributes']['title'] = t('Enter a valid time - e.g. @format', [
    '@format' => (new \DateTime())->format('h:i'),
  ]);
  if ($element['#date_time_element'] !== 'none') {
    $element['#date_time_format'] = 'H:i';
  }
  if (!empty($element['time']['#value'])) {
    $parts = explode(':', $element['time']['#value']);
    $parts = array_splice($parts, 0, 2);
    $element['time']['#value'] = implode(':', $parts);
  }
  // Remove seconds in browsers that support HTML5 type=date.
  $element['time']['#attributes']['step'] = 60;
  return $element;
}

/**
 * Implements hook_menu_links_discovered_alter().
 */
function workbc_ssot_menu_links_discovered_alter(&$links) {
  if (empty(\Drupal::config('workbc')->get('features.ssot_upload'))) {
    foreach ($links as $key => $link) {
      if (array_key_exists('route_name', $link) && in_array($link['route_name'], SSOT_ROUTES)) {
        unset($links[$key]);
      }
    }
  }
}


function ssot($endpoint, $method = 'GET', $options = [], $body = null): ResponseInterface | null {

  $ssot = \Drupal::config('workbc')->get('ssot_url');
  $client = new Client();
  try {
    switch (strtolower($method)) {
      case 'get':
        $response = $client->get($ssot . '/' . $endpoint, $options);
        break;
      case 'post':
      case 'patch':
        $options['body'] = $body;
        $response = $client->request($method, $ssot . '/' . $endpoint, $options);
        break;
    }
    return $response;
  }
  catch (RequestException $e) {
    \Drupal::logger('workbc')->error($e->getMessage());
    return null;
  }
}

function array_search_func(array &$arr, $func)
{
  foreach ($arr as $key => &$v)
    if ($func($key, $v))
      return $v;
  return null;
}
